Insertion Sort:
Insertion Sort works as the following, assume we have a pile of facing down cards, each time we receive a card, we would like to order them from smallest to highest. First, we would draw a card and put it in our left hand, since there is only one card, it’s sorted trivially. Then, we draw another card, comparing the new card with the card in our left hand and if the new card has a bigger value we put the new card on the right of the old card, otherwise we put it on the left.
*Worst Case: Let us begin with the worst case, since it will ease us into explaining the best case. Insertion sort has two for loops, the first one is to keep track of the size of the pre-existing unsorted array, and the second for loop is to find where the new element would be placed in the partially sorted array. Worst case occurs by doing maximum number of comparisons and swaps in the algorithm. Moreover, the first for loop always runs a fixed amount of comparisons because the computer does not have a bird’s eye view, it has to go through all the elements in order to sort them. Hence, it is only the second for loop that really matters, in most algorithms, adding a new element to the partially sorted array will start at the end of the partially sorted array. The new element would be compared to the last element of the partially sorted array, and shifting the last elements down if it is greater than the new element, thus, creating a hole for the placement of the new element. Supposed we want to achieve the maximum comparisons and swaps, all we need is the new element to be smaller than all of the elements in the partially sorted array. To achieve this, all we need is an array in descending order, an array starting from the largest value to the smallest value.
*Best Case: The best case of insertion is when the array is already in sorted order. Since, that would require the least comparisons and swaps for each new element that is trying to be placed into the partially sorted array.
 
Merge Sort:
Merge sort works as the following, when given an input array of fixed size, merge sort will split the array into two smaller arrays evenly until the size of the array contains only one element. Then, merge sort sorts each of the smaller arrays in order, usually from smallest to largest. Finally, the merge sort will then compare and merge the two smaller arrays back into one single array in sorted order.
 
*Worst Case: The merge part of the merge sort plays a huge role in the time complexity, since the merge sort will always split the original array into two smaller arrays. However, merging the two smaller arrays back into one will be affected at a constant time because it will only be dealing with the comparisons and swaps. To achieve the maximum comparisons and swaps, the two smaller arrays must have alternating ordered values, such as, value of 1,3,5 in one array and value of 2,4,6 in the other, where one array will not run out of the elements before the other.
 
*Best Case: The best case occurs when one of the two arrays runs out of elements before the other array, this occurs when all of the elements in one array are smaller than all of the elements in the other array. For instance, an array with value of 1,2,3 and another array with value of 4,5,6 will produce the best case.
 
The difference between insertion sort and merge sort is that merge sort has the same time complexity for best, average and worst case, while insertion sort has different time complexity for all three different cases. Merge sort has consistent time complexity because merge sort’s worst case takes n extra comparisons and swaps, while the best case takes extra n/2 comparisons and swaps. Since we drop constant terms in big o-notation, n/2 becomes just n. So, the best and worst time complexity for merge sort don’t change. The time complexity is different for insertion sort because at the worst insertion sort takes n extra comparisons and swaps, while at the best case takes extra constant time. This is a huge difference for insertion sort because in big o-notation the constant time can be forgotten, but the n variable could not. Thus, insertion sort has different time complexity for all three types of cases, and this is why merge sort is a better sort because merge sort is consistent through out the different types of cases.